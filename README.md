### 이 문서는 구현 과정과 시행착오, 코드리뷰와 성능 분석을 기록한 상세 개발 기록입니다


## Enter the Gungeon
![image](https://github.com/user-attachments/assets/37c2967b-158c-4c13-91d2-9ed5a920728f)

### 개요
- 게임 장르 : Roguelike
- 작업 기간 : 2024.10.15 ~ 2024.12.23(약 4개월)
- 기술 : C#, Unity Engine

### 프로젝트를 통해 얻은 점
#### 무작위 던전을 만들기 위한 수학적 지식
- 로그라이크다운 던전을 만들기 위해 겹치지 않게 방을 배치하거나, 자연스러운 다리를 구성하는 과정에서 기하학적 개념과 그래프 이론이 큰 도움이 되었습니다. 트히 들로네 삼각분할, 행렬을 이용한 기하 계산, 정규 분포와 같은 수학적 개념을 학습하고 코드에 직접 적용하면서 게임 구조를 설계하는 도구로 활용될 수 있다는 점을 느꼈습니다.

#### CSV 로딩 해결을 통한 성능 최적화
- 대용량의 CSV 파일을 읽을 때 많은 시간이 소요되어 개선하기 위해 고민하였습니다. CSV 대신 데이터를 바이너리로 변환하여 저장하고 게임을 실행할 때 빠른 속도로 읽어 병목 현상 완화와 함께, 단순한 데이터 구조 변경만으로 게임에 영향을 줄 수 있다는 성능 최적화의 중요성을 인식했습니다.

#### Unity 최적화 모듈 개발을 통한 퍼포먼스 개선 경험
- 많은 양의 데이터를 표시할 때 발생하는 렌더링 부하를 해결하기 위해 오브젝트 풀링을 사용하여 재사용 로직을 직접 구현하였습니다. 비활성 영역의 아이템을 자동으로 회수하고 가시 영역에만 렌더링이 일어나도록 설계하여 전체 연산량 감소 및 메모리 사용량 절감 효과를 달성했습니다.

### 주요 내용

#### 무작위 던전 생성기 [[코드 링크]](https://github.com/wdmab1204/EnterTheGungeon/blob/main/Client/Assets/Scripts/DungeonGenerator)
기능 : 유저가 던전에 입장할 때 마다 모양과 규칙이 다른 던전을 난수로 만들어내는 기능<br>
효과 : 유저가 매 번 새로운 던전을 탐험<br>

#### 초기 구현 과정
<img width="380" height="362" alt="Image" src="https://github.com/user-attachments/assets/dc41c404-aeb4-420d-ac42-e9ea91c6e422"/>

##### 예제코드가 많고 보편적인 Binary Space Partitioning 알고리즘을 이용해서 무작위 던전을 구현했습니다. 하지만 자연스럽지 않은 레이아웃과 인위적인 모습이 로그라이크와 어울리지 않다고 생각했습니다. 그리고 방을 잇는 다리를 직선으로 연결하니 다른 방을 가로지르는 현상까지 발견하여 전체적으로 수정이 필요하다고 느꼈습니다.

#### 개선안
//사진
##### 수많은 무작위 던전을 만드는 예제가 존재하나 클라이언트 개발자 답게 가장 이쁘게 나온다고 생각한 Delaunay Triangulation + MST을 조합한 방식을 채택했습니다. 이 방식은 유튜브 영상의 설명을 참고했으며 이론 개념은 아래의 웹페이지가 큰 도움을 주었습니다.
https://www.youtube.com/watch?v=rBY2Dzej03A
https://en.wikipedia.org/wiki/Delaunay_triangulation
https://juliageometry.github.io/DelaunayTriangulation.jl/stable/tutorials/operations_flip_edge/

#### 정규분포를 활용한 방 위치 배정
//사진
##### 처음에는 난수 생성기(System.Random)을 이용해 점(방의 위치)들을 무작위로 배치하여 무작위 던전을 구현했습니다. 하지만 직접 플레이 해보니 두 방을 오가는 거리가 너무 멀어 이동할 때 큰 지루함을 겪었습니다. 점들을 한곳에 모으면서 동시에 무작위로 배치할 방법을 고민하다 정규 분포를 알아냈고 난수 생성기 대신 이것을 사용하여 원하는 기능을 만들었습니다.

#### 들로네 삼각분할 + MST를 이용한 던전 생성기

//super triangle(사진)

//convex hull(사진)

##### 첫번째로 무작위 점들을 둘러쌓는 다각형이 필요합니다. 가장 대중적으로 알려져있는 방법은 가상의 super triangle을 만들어 모든 점들을 감싸는 것이지만 이것은 삽입 기반(incremental)을 기준으로 만들어진 방법이기 때문에 한번에 많은 점을 만드는 던전과 적합하지 않습니다. 대신 이런 상황을 위해 convex hull을 사용한다는 것을 알게되어 이 알고리즘을 채용했습니다.

##### 처음에는 임의의 두 점을 연결한 직선을 기준으로 정하고 모든 점들이 한쪽으로 치우쳐져 있으면 외곽선으로 판단하는 Brute Force 방식을 생각했으나 시간복잡도가 클 것으로 예상되어 유명한 구현방법인 그레이엄 스캔(Graham’s scan)방식을 채택했습니다. 이 과정에서 점이 선을 기준으로 어느쪽에 있는지 판별하는 방법이 필요했는데 아래 주소를 통해 행렬식을 얻어 쉽게 구할 수 있었습니다.
https://stackoverflow.com/questions/1560492/how-to-tell-whether-a-point-is-to-the-right-or-left-side-of-a-line?utm_source=chatgpt.com

//삼각분할(사진)
##### convex hull로 만들어진 볼록 다각형의 점들을 이용해서 삼각형으로 분할합니다. 단순하게 점 하나를 가지고 모든 점들과 연결하면 간단하게 삼각형이 만드는데 이게 가능한 이유는 볼록 다각형이기 때문인데 한곳이라도 오목한 곳이 있다면 분할 과정 중 선이 교차하게 되어 분할 조건이 성립하지 않기 때문입니다. 그 다음 나머지 볼록 다각형 안에 있는 점들은 만들어진 삼각형 리스트를 순회하여 점이 그 안에 포함되어있는지 조건을 확인합니다. 이 때 특정한 점이 삼각형안에 포함되는지 확인하는 방법은 아래의 행렬식을 사용했습니다.
http://totologic.blogspot.com/2014/01/accurate-point-in-triangle-test.html

//들로네 삼각분할(플립) (여긴 나중에 다시한번 공부해보고 재작성 또는 틀린거 체크)
##### 들로네 삼각분할도 여러가지 알고리즘이 존재하지만 가장 유명한 Incremental은 동적으로 점이 생길 때 유용하고, 이미 convex hull로 예쁘지 않지만 여튼 삼각형들을 만들었기 때문에, 이미 만들어져있는 삼각형들을 들로네 삼각분할 조건에 맞게 재정립하는 Flip 알고리즘을 채용했습니다.

###### Flip Condition을 달성하기 위해서 여러가지 조건이 필요합니다. 첫번째로 두 삼각형의 외접원에 맞은편 삼각형의 점이 포함되어선 안됩니다. 두번째로 맞닿은 모양이 볼록 사각형이여야 합니다. 그래서 모든 Half Edge를 순회하여 외접원 포함 유무와 볼록 사각형의 조건을 모두 확인합니다. 두 조건 모두 행렬식을 이용해서 구할 수 있었습니다.(볼록 사각형 유무는 좀더 공부) 최종적으로 점들은 방이 되고 변들은 방을 잇는 다리 역할을 하는 임의의 던전이 완성되었습니다.

##### 모든 삼각형의 Half Edge를 순회하여 Flip Condition 확인이 필요한데 행렬식을 이용해서 쉽게 조건식을 완성할 수 있었습니다. 최종적으로 모든 Flip Condition을 확인하고 수행한다면 들로네 삼각분할이 완성됩니다. //(외접원체크 두번하는 이유도 서술)
https://stackoverflow.com/questions/39984709/how-can-i-check-wether-a-point-is-inside-the-circumcircle-of-3-points

//최소신장트리 적용(사진)
##### 모든 방들을 방문할 수 있지만 같은 방을 다시 방문할 수 있는 루트(Cycle)가 존재합니다. 던전이 너무 복잡해지지 않기 위해 최소 신장 트리를 적용하여 최소한의 루트만 남깁니다.

#### 던전 전용 그리드 구현 및 A star를 이용한 복도 구현

##### 개선하기 전에 방과 방을 잇는 복도는 직선으로 구현하거나 ㄴ자 모양으로 나오도록 구현했습니다. 하지만 복도가 다른 방을 가로지르는 문제가 있었기 때문에 길찾기 알고리즘을 이용해서 던전의 구조를 파악하고 최적의 복도(경로)를 만드는 작업을 진행했습니다.

//사진
##### 처음에는 타일을 하나의 노드로 정의하고 A star로 방과 방을 잇는 최단 거리의 경로로 복도를 구현했습니다. 하지만 복도를 두껍게하고 벽을 세우는 과정에서 다시한번 방과 겹치는 이슈가 발생했는데 경로를 계산하는 과정에서 복도의 두께까지 가정하지 않았기 때문입니다. 노드마다 복도의 두께만큼 반경에 다른 타일이 있는지 검사하는 방법이 있지만 안그래도 많은 노드 개수에 추가 비용이 드는건 좋지 않다고 생각해 5x5 타일들을 하나의 노드로 재정의하는 방법을 채용했습니다. 5x5 타일 내에서 복도를 자유롭게 표현할 수 있고 노드의 크기도 커져 전체적인 노드 개수도 줄어들어 A*의 연산 속도고 개선되는 일석이조의 효과를 얻었습니다.

//최종 결과

//그리드 적용 전과 후의 성능 기록

#### 미니맵 구현
기능 : 유저가 입장한 던전의 모습을 한눈에 볼 수 있는 UI
효과 : 복잡한 던전에서 길을 헤메지 않아 쉽게 게임 플레이 가능

#### 던전의 모습을 UI로 시각화

##### 단순히 카메라로 멀리 비춰진 던전을 보여주는 것이 아닌 던전의 모습에 맞게 동적으로 텍스쳐를 만들고 싶었습니다. 처음에는 UI전용 LineRenderer를 구현하여 던전의 모습에 맞게 텍스쳐를 그렸습니다. 하지만 너무 단조로웠고 밋밋해서 바닥은 하얀색, 벽면이나 방 안의 빈 공간은 검은색 선으로 칠해보고 싶었습니다.

##### 외곽 라인을 그리기 위해 임의의 벽 타일을 골라 이어지는 다른 타일을 따라 라인을 그렸습니다. 하지만 벽이 만약 여러개라면 더이상 방문한 벽이 없어질 때 까지 방의 타일들을 여러번 순회해야합니다. 최악의 경우 N^2의 시간복잡도를 가지게 되는데 다행히 외곽라인 알고리즘 관련 자료를 찾게 되어 4N의 시간복잡도로 그칠 수 있었습니다.
https://www.youtube.com/watch?v=ku_thRxLXPw

##### 타일마다 시계방향의 위치 벡터 4개를 저장하는데 순회 중 시작과 끝점이 같거나 서로 반대인 벡터가 있다면 그 벡터를 제거합니다. 그러면 최종적으로 외벽을 이루는 시계방향 벡터, 내벽을 이루는 반시계방향 벡터로 나뉘게 됩니다. 이를 응용해서 내벽을 그릴 때 외벽과 다른 색으로 하는것도 가능합니다.

#### 던전 내비게이션 시스템

##### 몬스터는 플레이어를 공격하기 위해, 동전은 플레이어에게 먹히기 위해 자동으로 추적해야 합니다. 단순한 길찾기이기 때문에 익숙한 A star 알고리즘을 사용했으나, 던전에 8마리의 몬스터가 동시에 길찾기를 사용했을 경우 한 프레임에 cpu 전체 사용량의 평균 49%나 차지한다는 점에서 적지 않은 충격을 먹었습니다. 프레임 드랍의 원인이 될 수 있기 때문에 반드시 개선이 필요하다고 생각해 두가지 방법을 고안했습니다.

|  | A star | Unity NavMesh |
| :-:  | :-: | :-: |
| Call| 8 | 8 |
| 평균 CPU 점유율 | 49% | 0.8% |
| GC Allock | 137KB | 0B |
| Time ms | 1.34 | 0.01 |

##### 처음에는 길찾기 요청을 Queue에 담아 프레임마다 순차적으로 처리하는 방식을 구상했습니다. 이 방법은 모든 몬스터의 경로 계산을 여러 프레임으로 분산시킬 수 있어 효율적이라 판단했습니다. 그러나 최악의 경우 특정 프레임에서 병목 현상이 발생할 가능성이 있었습니다. 이를 보완하기 위해 Thread를 활용한 병렬 계산을 고려했지만, Unity WebGL 환경에서는 MultiThread가 지원되지 않는 제약이 있었습니다. 최종적으로는 UniTask를 활용하여 경로 계산 비용을 여러 프레임으로 분산 처리함으로써, 성능을 유지하면서도 WebGL 환경에서도 안정적으로 동작하도록 구현했습니다.

##### 초기 구현에서는 Grid의 Cell을 직접 참조한 뒤 방문한 Cell을 초기화하는 방식으로 경로 계산을 처리했습니다. 그러나 UniTask 기반 비동기 구조로 전환하면서 여러 작업에서 동시에 Cell을 참조하게 되었고, 이로 인해 계산 결과가 불안정해지는 문제가 발생했습니다. 문제를 해결하기 위해 깊은 복사 방식을 도입했지만, 매번 복사가 일어나면서 많은 Garbage가 생성되었습니다. 이에 class 대신 struct를 활용하여 불필요한 메모리 할당을 줄이고, 안정적인 계산과 성능 최적화를 동시에 달성할 수 있었습니다. 이를 통해 GC 발생 빈도를 크게 줄이고, Spike로 인한 프레임 드랍 가능성을 제거했습니다.

##### 몬스터가 경로를 역방향으로 이동하는 문제가 발생했습니다. 이는 경로 요청 시점의 몬스터 위치와 실제 경로 계산 완료 시점의 위치가 불일치하여, 몬스터가 과거 위치를 기준으로 경로를 따르면서 나타난 현상이었습니다. 해결 과정에서는 웨이포인트 중 현재 진행 방향과 반대에 위치한 지점을 무시하도록 로직을 수정하였습니다. 이를 위해 몬스터의 실제 이동 벡터와 다음 웨이포인트 방향 벡터 간의 내적 연산을 적용하여, 진행 방향과 일치하지 않는 경우 해당 웨이포인트를 제외하도록 구현하였습니다. 그 결과, 몬스터의 움직임이 자연스러워지고 불필요한 방향 전환으로 인한 이질감이 해소되었습니다.

//성과 표 작성