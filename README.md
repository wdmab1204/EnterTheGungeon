### 이 문서는 구현 과정과 시행착오, 코드리뷰와 성능 분석을 기록한 상세 개발 기록입니다
![Recording 2025-08-30 at 16 22 20](https://github.com/user-attachments/assets/95b35484-a8e9-476c-91b5-ca83c42ac873)
# Enter the Gungeon
![image](https://github.com/user-attachments/assets/37c2967b-158c-4c13-91d2-9ed5a920728f)

### 개요
- 게임 장르 : Roguelike
- 작업 기간 : 2024.10.15 ~ 현재 진행중
- 기술 : C#, Unity Engine

목차
---
* 무작위 던전 생성기
* 미니맵 구현
* 던전 내비게이션 시스템


### 무작위 던전 생성기 [[코드 링크]](https://github.com/wdmab1204/EnterTheGungeon/blob/main/Client/Assets/Scripts/DungeonGenerator)
기능 : 유저가 던전에 입장할 때 마다 모양과 규칙이 다른 던전을 난수로 만들어내는 기능<br>
효과 : 유저가 매 번 새로운 던전을 탐험<br>

### 초기 구현 과정
<img width="760" height="724" alt="Image" src="https://github.com/user-attachments/assets/dc41c404-aeb4-420d-ac42-e9ea91c6e422"/>

예제 코드가 많고 보편적으로 사용되는 Binary Space Partitioning (BSP) 알고리즘을 적용하여 무작위 던전을 생성했습니다. BSP는 구현이 간단하고 방과 복도를 쉽게 정의할 수 있다는 장점이 있어 빠르게 프로토타입을 제작하기에 적합했습니다.

그러나 결과물은 방의 크기와 배치가 지나치게 규칙적이고, 복도가 직선적으로 연결되는 경향이 강해 자연스러운 레이아웃보다는 인위적인 격자 구조에 가까웠습니다. 특히 로그라이크 장르가 요구하는 무작위성과 탐험의 재미를 살리기에는 부족하다고 판단했습니다.

또한 방을 직선으로 연결하는 과정에서 다른 방을 가로지르는 현상까지 발생하여, 구조적으로 개선이 필요하다고 느꼈습니다.

### 개선안
<img width="788" height="830" alt="image" src="https://github.com/user-attachments/assets/4447b641-5b4f-43ee-9469-27cd51ced40a" />

###### 실제 구현 화면입니다
무작위 던전을 생성하는 다양한 알고리즘 예제가 존재하지만, 단순히 동작하는 수준이 아니라 플레이어가 보기에 자연스럽고 탐험 욕구를 불러일으키는 맵을 만드는 것이 목표였습니다. 그 결과, Delaunay Triangulation과 MST(Minimum Spanning Tree)를 조합한 방식을 채택했습니다.

이 접근법의 장점은 다음과 같습니다.

자연스러운 방 배치 : Delaunay Triangulation을 통해 방들이 균형 잡힌 형태로 연결되며, 불필요하게 삐뚤어지거나 겹치는 배치를 방지할 수 있습니다.

불필요한 교차 제거 : MST를 적용하여 최소한의 다리만 남기면서도 모든 방이 연결되도록 보장해, 다른 방을 가로지르는 문제를 해소했습니다.

확장성 : 생성된 그래프를 기반으로 사이클을 일부 복원하거나, 특정 규칙을 추가해 더 다양한 맵 구조를 만들 수 있습니다.

해당 구현은 유튜브 영상의 설명을 참고했으며, 알고리즘의 이론적 배경은 아래 웹페이지에서 큰 도움을 받았습니다. 이를 통해 기존보다 시각적으로 자연스러운 레이아웃과, 탐험하기에 적합한 던전 구조를 구현할 수 있었습니다.<br>
https://www.youtube.com/watch?v=rBY2Dzej03A<br>
https://en.wikipedia.org/wiki/Delaunay_triangulation<br>
https://juliageometry.github.io/DelaunayTriangulation.jl/stable/tutorials/operations_flip_edge/<br>

### 정규분포를 활용한 방 위치 배정
<img width="1453" height="821" alt="image" src="https://github.com/user-attachments/assets/bbf5e235-2656-4d92-9d72-fd069e3642ea" />

처음에는 난수 생성기(System.Random)를 이용해 방 위치를 무작위로 배치하여 던전을 구현했습니다. 그러나 직접 플레이해보니, 방 간 거리가 지나치게 멀어 이동 시 지루함이 발생하는 문제가 있었습니다.

이를 개선하기 위해 방 위치를 한곳에 모으면서도 무작위성을 유지할 수 있는 방법을 고민했고, **정규 분포(Normal Distribution)**를 활용하는 아이디어를 적용했습니다. 난수 생성기 대신 정규 분포를 사용함으로써, 방들이 자연스럽게 군집을 이루면서도 무작위로 배치되도록 구현할 수 있었습니다.

그 결과, 플레이어가 탐험할 때 이동 거리가 적절하게 분포되어 던전 탐험의 재미와 몰입도를 동시에 높일 수 있었습니다.

### 들로네 삼각분할 + MST를 이용한 던전 생성기

<img width="595" height="613" alt="image" src="https://github.com/user-attachments/assets/aa8fb8af-2bf4-4d69-8e1d-cb6700406739" />




#### 첫번째로 무작위 점들을 둘러쌓는 다각형이 필요합니다. 가장 대중적으로 알려져있는 방법은 가상의 super triangle을 만들어 모든 점들을 감싸는 것이지만 이것은 삽입 기반(incremental)을 기준으로 만들어진 방법이기 때문에 한번에 많은 점을 만드는 던전과 적합하지 않습니다. 대신 이런 상황을 위해 convex hull을 사용한다는 것을 알게되어 이 알고리즘을 채용했습니다.

#### 처음에는 임의의 두 점을 연결한 직선을 기준으로 정하고 모든 점들이 한쪽으로 치우쳐져 있으면 외곽선으로 판단하는 Brute Force 방식을 생각했으나 시간복잡도가 클 것으로 예상되어 유명한 구현방법인 그레이엄 스캔(Graham’s scan)방식을 채택했습니다. 이 과정에서 점이 선을 기준으로 어느쪽에 있는지 판별하는 방법이 필요했는데 아래 주소를 통해 행렬식을 얻어 쉽게 구할 수 있었습니다.
https://stackoverflow.com/questions/1560492/how-to-tell-whether-a-point-is-to-the-right-or-left-side-of-a-line

<img width="595" height="612" alt="image" src="https://github.com/user-attachments/assets/cf8543e3-3f13-4f8e-9725-6efe40d85c41" />

<img width="578" height="593" alt="image" src="https://github.com/user-attachments/assets/7dfcfe6e-e02a-4e28-beb0-70cf74f2f788" />



#### convex hull로 만들어진 볼록 다각형의 점들을 이용해서 삼각형으로 분할합니다. 단순하게 점 하나를 가지고 모든 점들과 연결하면 간단하게 삼각형이 만드는데 이게 가능한 이유는 볼록 다각형이기 때문인데 한곳이라도 오목한 곳이 있다면 분할 과정 중 선이 교차하게 되어 분할 조건이 성립하지 않기 때문입니다. 그 다음 나머지 볼록 다각형 안에 있는 점들은 만들어진 삼각형 리스트를 순회하여 점이 그 안에 포함되어있는지 조건을 확인합니다. 이 때 특정한 점이 삼각형안에 포함되는지 확인하는 방법은 아래의 행렬식을 사용했습니다.
http://totologic.blogspot.com/2014/01/accurate-point-in-triangle-test.html

<img width="580" height="598" alt="image" src="https://github.com/user-attachments/assets/0f7d3e6a-a697-4eaa-b65c-6f4c4bbe6b70" />



#### 들로네 삼각분할도 여러가지 알고리즘이 존재하지만 가장 유명한 Incremental은 동적으로 점이 생길 때 유용하고, 이미 convex hull로 예쁘지 않지만 여튼 삼각형들을 만들었기 때문에, 이미 만들어져있는 삼각형들을 들로네 삼각분할 조건에 맞게 재정립하는 Flip 알고리즘을 채용했습니다.

#### Flip Condition을 달성하기 위해서 여러가지 조건이 필요합니다. 첫번째로 두 삼각형의 외접원에 맞은편 삼각형의 점이 포함되어선 안됩니다. 두번째로 맞닿은 모양이 볼록 사각형이여야 합니다. 그래서 모든 Half Edge를 순회하여 외접원 포함 유무와 볼록 사각형의 조건을 모두 확인합니다. 두 조건 모두 행렬식을 이용해서 구할 수 있었습니다.(볼록 사각형 유무는 좀더 공부) 최종적으로 점들은 방이 되고 변들은 방을 잇는 다리 역할을 하는 임의의 던전이 완성되었습니다.

#### 모든 삼각형의 Half Edge를 순회하여 Flip Condition 확인이 필요한데 행렬식을 이용해서 쉽게 조건식을 완성할 수 있었습니다. 최종적으로 모든 Flip Condition을 확인하고 수행한다면 들로네 삼각분할이 완성됩니다. //(외접원체크 두번하는 이유도 서술)
https://stackoverflow.com/questions/39984709/how-can-i-check-wether-a-point-is-inside-the-circumcircle-of-3-points
<img width="540" height="580" alt="image" src="https://github.com/user-attachments/assets/f6935ae9-4cb7-4064-ba66-2011b32b2e6d" />


#### 모든 방들을 방문할 수 있지만 같은 방을 다시 방문할 수 있는 루트(Cycle)가 존재합니다. 던전이 너무 복잡해지지 않기 위해 최소 신장 트리를 적용하여 최소한의 루트만 남깁니다.

### 던전 전용 그리드 구현 및 A star를 이용한 복도 구현

#### 개선하기 전에 방과 방을 잇는 복도는 직선으로 구현하거나 ㄴ자 모양으로 나오도록 구현했습니다. 하지만 복도가 다른 방을 가로지르는 문제가 있었기 때문에 길찾기 알고리즘을 이용해서 던전의 구조를 파악하고 최적의 복도(경로)를 만드는 작업을 진행했습니다.

#### 처음에는 타일을 하나의 노드로 정의하고 A star로 방과 방을 잇는 최단 거리의 경로로 복도를 구현했습니다. 하지만 복도를 두껍게하고 벽을 세우는 과정에서 다시한번 방과 겹치는 이슈가 발생했는데 경로를 계산하는 과정에서 복도의 두께까지 가정하지 않았기 때문입니다. 노드마다 복도의 두께만큼 반경에 다른 타일이 있는지 검사하는 방법이 있지만 안그래도 많은 노드 개수에 추가 비용이 드는건 좋지 않다고 생각해 5x5 타일들을 하나의 노드로 재정의하는 방법을 채용했습니다. 5x5 타일 내에서 복도를 자유롭게 표현할 수 있고 노드의 크기도 커져 전체적인 노드 개수도 줄어들어 A*의 연산 속도고 개선되는 일석이조의 효과를 얻었습니다.

<img width="595" height="597" alt="image" src="https://github.com/user-attachments/assets/690a7572-f691-4f09-b74d-4c7d2e0bd1de" />

<img width="637" height="602" alt="image" src="https://github.com/user-attachments/assets/956d59a3-9a16-4044-bfd4-df6ee0692bd9" />


### 미니맵 구현
<img width="614" height="606" alt="image" src="https://github.com/user-attachments/assets/6e68fea1-f3b1-422e-9d03-53face401eeb" />

기능 : 유저가 입장한 던전의 모습을 한눈에 볼 수 있는 UI
효과 : 복잡한 던전에서 길을 헤메지 않아 쉽게 게임 플레이 가능

### 던전의 모습을 UI로 시각화

#### 단순히 카메라로 멀리 비춰진 던전을 보여주는 것이 아닌 던전의 모습에 맞게 동적으로 텍스쳐를 만들고 싶었습니다. 처음에는 UI전용 LineRenderer를 구현하여 던전의 모습에 맞게 텍스쳐를 그렸습니다. 하지만 너무 단조로웠고 밋밋해서 바닥은 하얀색, 벽면이나 방 안의 빈 공간은 검은색 선으로 칠해보고 싶었습니다.

#### 외곽 라인을 그리기 위해 임의의 벽 타일을 골라 이어지는 다른 타일을 따라 라인을 그렸습니다. 하지만 벽이 만약 여러개라면 더이상 방문한 벽이 없어질 때 까지 방의 타일들을 여러번 순회해야합니다. 최악의 경우 N^2의 시간복잡도를 가지게 되는데 다행히 외곽라인 알고리즘 관련 자료를 찾게 되어 4N의 시간복잡도로 그칠 수 있었습니다.
https://www.youtube.com/watch?v=ku_thRxLXPw

#### 타일마다 시계방향의 위치 벡터 4개를 저장하는데 순회 중 시작과 끝점이 같거나 서로 반대인 벡터가 있다면 그 벡터를 제거합니다. 그러면 최종적으로 외벽을 이루는 시계방향 벡터, 내벽을 이루는 반시계방향 벡터로 나뉘게 됩니다. 이를 응용해서 내벽을 그릴 때 외벽과 다른 색으로 하는것도 가능합니다.

### 던전 내비게이션 시스템
<img width="626" height="602" alt="image" src="https://github.com/user-attachments/assets/26f8de5e-65bc-420f-9665-71895d1e2c1b" />

#### 몬스터는 플레이어를 공격하기 위해, 동전은 플레이어에게 먹히기 위해 자동으로 추적해야 합니다. 단순한 길찾기이기 때문에 익숙한 A star 알고리즘을 사용했으나, 던전에 8마리의 몬스터가 동시에 길찾기를 사용했을 경우 한 프레임에 cpu 전체 사용량의 평균 49%나 차지한다는 점에서 적지 않은 충격을 먹었습니다. 프레임 드랍의 원인이 될 수 있기 때문에 반드시 개선이 필요하다고 생각해 두가지 방법을 고안했습니다.

|  | A star | Unity NavMesh |
| :-:  | :-: | :-: |
| Call| 8 | 8 |
| 평균 CPU 점유율 | 49% | 0.8% |
| GC Allock | 137KB | 0B |
| Time ms | 1.34 | 0.01 |

#### 처음에는 길찾기 요청을 Queue에 담아 프레임마다 순차적으로 처리하는 방식을 구상했습니다. 이 방법은 모든 몬스터의 경로 계산을 여러 프레임으로 분산시킬 수 있어 효율적이라 판단했습니다. 그러나 최악의 경우 특정 프레임에서 병목 현상이 발생할 가능성이 있었습니다. 이를 보완하기 위해 Thread를 활용한 병렬 계산을 고려했지만, Unity WebGL 환경에서는 MultiThread가 지원되지 않는 제약이 있었습니다. 최종적으로는 UniTask를 활용하여 경로 계산 비용을 여러 프레임으로 분산 처리함으로써, 성능을 유지하면서도 WebGL 환경에서도 안정적으로 동작하도록 구현했습니다.

#### 초기 구현에서는 Grid의 Cell을 직접 참조한 뒤 방문한 Cell을 초기화하는 방식으로 경로 계산을 처리했습니다. 그러나 UniTask 기반 비동기 구조로 전환하면서 여러 작업에서 동시에 Cell을 참조하게 되었고, 이로 인해 계산 결과가 불안정해지는 문제가 발생했습니다. 문제를 해결하기 위해 깊은 복사 방식을 도입했지만, 매번 복사가 일어나면서 많은 Garbage가 생성되었습니다. 이에 class 대신 struct를 활용하여 불필요한 메모리 할당을 줄이고, 안정적인 계산과 성능 최적화를 동시에 달성할 수 있었습니다. 이를 통해 GC 발생 빈도를 크게 줄이고, Spike로 인한 프레임 드랍 가능성을 제거했습니다.

![Recording 2025-08-30 at 16 33 59](https://github.com/user-attachments/assets/15795f38-583d-492d-b5ea-bc0ff6b2d8b8)

##### 몬스터가 경로를 역방향으로 이동하는 문제가 발생했습니다. 이는 경로 요청 시점의 몬스터 위치와 실제 경로 계산 완료 시점의 위치가 불일치하여, 몬스터가 과거 위치를 기준으로 경로를 따르면서 나타난 현상이었습니다. 해결 과정에서는 웨이포인트 중 현재 진행 방향과 반대에 위치한 지점을 무시하도록 로직을 수정하였습니다. 이를 위해 몬스터의 실제 이동 벡터와 다음 웨이포인트 방향 벡터 간의 내적 연산을 적용하여, 진행 방향과 일치하지 않는 경우 해당 웨이포인트를 제외하도록 구현하였습니다. 그 결과, 몬스터의 움직임이 자연스러워지고 불필요한 방향 전환으로 인한 이질감이 해소되었습니다.

//성과 표 작성
